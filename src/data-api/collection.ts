// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import { takeWhile } from './utils';
import { FindCursor } from '@/src/data-api/cursor';
import { Db, replaceRawId, SomeDoc } from '@/src/data-api';
import {
  BulkWriteError,
  DataAPIResponseError,
  DeleteManyError,
  InsertManyError,
  mkRespErrorFromResponse,
  mkRespErrorFromResponses,
  TooManyDocsToCountError,
  UpdateManyError
} from '@/src/data-api/errors';
import objectHash from 'object-hash';
import { DataApiHttpClient } from '@/src/api';
import {
  AnyBulkWriteOperation,
  BaseOptions,
  BulkWriteOptions,
  BulkWriteResult,
  CollectionOptions,
  DeleteManyCommand,
  DeleteManyResult,
  DeleteOneCommand,
  DeleteOneOptions,
  DeleteOneResult,
  Filter,
  FindOneAndDeleteCommand,
  FindOneAndDeleteOptions,
  FindOneAndReplaceCommand,
  FindOneAndReplaceOptions,
  findOneAndReplaceOptionsKeys,
  FindOneAndUpdateCommand,
  FindOneAndUpdateOptions,
  findOneAndUpdateOptionsKeys,
  FindOneCommand,
  FindOneOptions,
  findOneOptionsKeys,
  FindOptions,
  Flatten,
  FoundDoc,
  IdOf,
  InsertManyCommand,
  insertManyOptionKeys,
  InsertManyOptions,
  InsertManyResult,
  InsertOneCommand, InsertOneOptions,
  InsertOneResult, MaybeId,
  ModifyResult,
  Mutable,
  NoId,
  ReplaceOneOptions,
  ReplaceOneResult,
  ToDotNotation,
  UpdateFilter,
  UpdateManyCommand,
  UpdateManyOptions,
  UpdateManyResult,
  UpdateOneCommand,
  updateOneOptionKeys,
  UpdateOneOptions,
  UpdateOneResult,
  WithId
} from '@/src/data-api/types';

/**
 * Represents the interface to a collection in the database.
 *
 * **Shouldn't be directly instantiated, but rather created via {@link Db.createCollection},
 * or connected to using {@link Db.collection}**.
 *
 * Typed as `Collection<Schema>` where `Schema` is the type of the documents in the collection.
 * Operations on the collection will be strongly typed if a specific schema is provided, otherwise
 * remained largely weakly typed if no type is provided, which may be preferred for dynamic data
 * access & operations.
 *
 * @example
 * ```typescript
 * const collection = await db.createCollection<PersonSchema>('my_collection');
 * await collection.insertOne({ _id: '1', name: 'John Doe' });
 * await collection.drop();
 * ```
 *
 * @see SomeDoc
 * @see VectorDoc
 */
export class Collection<Schema extends SomeDoc = SomeDoc> {
  private readonly _httpClient!: DataApiHttpClient;
  private readonly _db!: Db

  /**
   * The name of the collection.
   */
  public readonly collectionName!: string;

  /**
   * The namespace (aka keyspace) that the collection lives in.
   */
  public readonly namespace!: string;

  /**
   * Use {@link Db.collection} to obtain an instance of this class.
   *
   * @internal
   */
  constructor(db: Db, httpClient: DataApiHttpClient, name: string, namespace: string | undefined) {
    Object.defineProperty(this, 'collectionName', {
      value: name,
      writable: false,
    });

    Object.defineProperty(this, 'namespace', {
      value: namespace ?? db.namespace,
      writable: false,
    });

    Object.defineProperty(this, '_httpClient', {
      value: httpClient.cloneInto(DataApiHttpClient, c => {
        c.collection = this.collectionName;
        c.namespace = this.namespace;
      }),
      enumerable: false,
    });

    Object.defineProperty(this, '_db', {
      value: db,
      enumerable: false,
    });
  }

  /**
   * Inserts a single document into the collection atomically.
   *
   * If the document does not contain an `_id` field, the server will generate an id for the document. The type of the
   * id may be specified in {@link CollectionOptions.defaultId} @ creation, otherwise it'll just be a UUID string. This
   * generation will not mutate the documents.
   *
   * If an `_id` is provided which corresponds to a document that already exists in the collection, an error is raised,
   * and the insertion fails.
   *
   * See {@link InsertOneOptions} for complete information about the options available for this operation.
   *
   * @example
   * ```typescript
   * // Insert a document with a specific ID
   * await collection.insertOne({ _id: '1', name: 'John Doe' });
   *
   * // Insert a document with an autogenerated ID
   * await collection.insertOne({ name: 'Jane Doe' });
   *
   * // Insert a document with a vector
   * await collection.insertOne({ name: 'Jane Doe' }, { vector: [.12, .52, .32] });
   * await collection.insertOne({ name: 'Jane Doe', $vector: [.12, .52, .32] });
   * ```
   *
   * @param document - The document to insert.
   * @param options - The options for this operation.
   *
   * @return The result of the operation.
   */
  async insertOne(document: MaybeId<Schema>, options?: InsertOneOptions): Promise<InsertOneResult<Schema>> {
    const command: InsertOneCommand = {
      insertOne: { document },
    }

    if (options?.vector) {
      command.insertOne.document = { ...command.insertOne.document, $vector: options.vector };
    }

    const resp = await this._httpClient.executeCommand(command, options);

    return {
      insertedId: replaceRawId(resp.status?.insertedIds[0]),
    };
  }

  /**
   * Inserts many documents into the collection.
   *
   * **NB. This function paginates the insertion of documents in chunks to avoid running into insertion limits. This
   * means multiple requests may be made to the server, and the operation may not be atomic.**
   *
   * If any document does not contain an `_id` field, the server will generate an id for the document. The type of the
   * id may be specified in {@link CollectionOptions.defaultId} @ creation, otherwise it'll just be a UUID string. This
   * generation will not mutate the documents.
   *
   * You may set the `ordered` option to `true` to stop the operation after the first error; otherwise all documents
   * may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
   *
   * If an insertion error occurs, the operation will throw an {@link InsertManyError} containing the partial result.
   *
   * *If the exception is not due to an insertion error, e.g. a `5xx` error or network error, the operation will throw the
   * underlying error.*
   *
   * *In case of an unordered request, if the error was a simple insertion error, a `InsertManyError` will be thrown
   * after every document has been attempted to be inserted. If it was a `5xx` or similar, the error will be thrown
   * immediately.*
   *
   * You can set the `concurrency` option to control how many network requests are made in parallel on unordered
   * insertions. Defaults to `8`.
   *
   * You can set the `chunkSize` option to control how many documents are inserted in each network request. Defaults to `20`,
   * the Data API limit.
   *
   * See {@link InsertManyOptions} for complete information about the options available for this operation.
   *
   * @example
   * ```typescript
   * try {
   *   await collection.insertMany([
   *     { _id: '1', name: 'John Doe' },
   *     { name: 'Jane Doe' },
   *   ], { ordered: true });
   *
   *   await collection.insertMany([
   *     { _id: '1', name: 'John Doe', $vector: [.12, .52, .32] },
   *     { name: 'Jane Doe', $vector: [.32, .52, .12] },
   *   ]);
   *
   *   await collection.insertMany([
   *     { _id: '1', name: 'John Doe' },
   *     { name: 'Jane Doe' },
   *   ], {
   *     vectors: [
   *       [.12, .52, .32],
   *       [.32, .52, .12],
   *     ],
   *     ordered: true,
   *   });
   * } catch (e) {
   *   if (e instanceof InsertManyError) {
   *     console.log(e.insertedIds);
   *   }
   * }
   * ```
   *
   * @remarks
   * This operation is not atomic. Depending on the amount of inserted documents, and if it's ordered or not, it can
   * keep running (in a blocking way) for a macroscopic amount of time. In that case, new documents that are inserted
   * from another concurrent process/application may be inserted during the execution of this method call, and if there
   * are duplicate keys, it's not easy to predict which application will win the race.
   *
   * @param documents - The documents to insert.
   * @param options - The options for this operation.
   *
   * @return The aggregated result of the operation.
   *
   * @throws InsertManyError - If the operation fails.
   */
  async insertMany(documents: MaybeId<Schema>[], options?: InsertManyOptions): Promise<InsertManyResult<Schema>> {
    const chunkSize = options?.chunkSize ?? 20;

    if (options?.vectors) {
      if (options.vectors.length !== documents.length) {
        throw new Error('The number of vectors must match the number of documents');
      }

      for (let i = 0, n = documents.length; i < n; i++) {
        if (options.vectors[i]) {
          documents[i] = { ...documents[i], $vector: options.vectors[i] };
        }
      }
    }

    const insertedIds = (options?.ordered)
      ? await insertManyOrdered<Schema>(this._httpClient, documents, chunkSize)
      : await insertManyUnordered<Schema>(this._httpClient, documents, options?.concurrency ?? 8, chunkSize);

    insertedIds.forEach(replaceRawId);

    return {
      insertedCount: insertedIds.length,
      insertedIds: insertedIds,
    }
  }

  /**
   * Atomically updates a single document in the collection.
   *
   * If `upsert` is set to true, it will insert the document if no match is found.
   *
   * You can also specify a sort option to determine which document to update if multiple documents match the filter.
   *
   * See {@link UpdateOneOptions} for complete information about the options available for this operation.
   *
   * @example
   * ```typescript
   * // Update by ID
   * await collection.insertOne({ _id: '1', name: 'John Doe' });
   *
   * await collection.updateOne(
   *   { _id: '1' },
   *   { $set: { name: 'Jane Doe' }
   * });
   *
   * // Update by vector search
   * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
   *
   * await collection.updateOne(
   *   {},
   *   { $set: { name: 'Jane Doe' } },
   *   { vector: [.09, .58, .21] }
   * );
   *
   * await collection.updateOne(
   *   {},
   *   { $set: { name: 'Jane Doe' } },
   *   { sort: { $vector: [.09, .58, .21] } }
   * );
   * ```
   *
   * @param filter - A filter to select the document to update.
   * @param update - The update to apply to the selected document.
   * @param options - The options for this operation.
   *
   * @return The result of the operation.
   *
   * @see StrictFilter
   * @see StrictUpdateFilter
   */
  async updateOne(filter: Filter<Schema>, update: UpdateFilter<Schema>, options?: UpdateOneOptions<Schema>): Promise<UpdateOneResult> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: UpdateOneCommand = {
      updateOne: {
        filter,
        update,
        options: {
          upsert: options?.upsert,
        },
      },
    };

    if (options?.sort) {
      command.updateOne.sort = options.sort;
    }

    const resp = await this._httpClient.executeCommand(command, options, updateOneOptionKeys);

    const commonResult = {
      modifiedCount: resp.status?.modifiedCount,
      matchedCount: resp.status?.matchedCount,
    } as const;

    return (resp.status?.upsertedId)
      ? {
        ...commonResult,
        upsertedId: replaceRawId(resp.status?.upsertedId),
        upsertedCount: 1,
      }
      : commonResult;
  }

  /**
   * Updates many documents in the collection.
   *
   * **NB. This function paginates the updating of documents in chunks to avoid running into insertion limits. This
   * means multiple requests may be made to the server, and the operation may not be atomic.**
   *
   * If `upsert` is set to true, it will insert a document if no match is found.
   *
   * You can also specify a sort option to determine which documents to update if multiple documents match the filter.
   *
   * See {@link UpdateManyOptions} for complete information about the options available for this operation.
   *
   * @example
   * ```typescript
   * await collection.insertMany([
   *   { _id: '1', name: 'John Doe', car: 'Renault Twizy' },
   *   { _id: UUID.v4(), name: 'Jane Doe' },
   *   { name: 'Dane Joe' },
   * ]);
   *
   * // Will give 'Jane' and 'Dane' a car 'unknown'
   * await collection.updateMany({
   *   car: { $exists: false },
   * }, {
   *   $set: { car: 'unknown' },
   * });
   *
   * // Will upsert a document with name 'Anette' and car 'Volvo v90'
   * await collection.updateMany({
   *   name: 'Anette',
   * }, {
   *   $set: { car: 'Volvo v90' },
   * }, {
   *   upsert: true,
   * });
   * ```
   *
   * @remarks
   * This operation is not atomic. Depending on the amount of matching documents, it can keep running (in a blocking
   * way) for a macroscopic amount of time. In that case, new documents that are inserted from another concurrent process/
   * application at the same time may be updated during the execution of this method call. In other words, it cannot
   * easily be predicted whether a given newly-inserted document will be picked up by the updateMany command or not.
   *
   * @param filter - A filter to select the documents to update.
   * @param update - The update to apply to the selected documents.
   * @param options - The options for this operation.
   *
   * @return The aggregated result of the operation.
   *
   * @see StrictFilter
   * @see StrictUpdateFilter
   */
  async updateMany(filter: Filter<Schema>, update: UpdateFilter<Schema>, options?: UpdateManyOptions): Promise<UpdateManyResult> {
    const command: UpdateManyCommand = {
      updateMany: {
        filter,
        update,
        options: {
          upsert: options?.upsert,
        },
      },
    };

    const commonResult = {
      modifiedCount: 0,
      matchedCount: 0,
    };

    let resp;

    try {
      while (!resp || resp.status?.nextPageState) {
        resp = await this._httpClient.executeCommand(command);
        command.updateMany.options.pagingState = resp.status?.nextPageState ;
        commonResult.modifiedCount += resp.status?.modifiedCount ?? 0;
        commonResult.matchedCount += resp.status?.matchedCount ?? 0;
      }
    } catch (e) {
      if (!(e instanceof DataAPIResponseError)) {
        throw e;
      }
      const desc = e.detailedErrorDescriptors[0];

      commonResult.modifiedCount += desc.rawResponse?.status?.modifiedCount ?? 0;
      commonResult.matchedCount += desc.rawResponse?.status?.matchedCount ?? 0;

      throw mkRespErrorFromResponse(UpdateManyError, command, desc.rawResponse, commonResult);
    }

    return (resp.status?.upsertedId)
      ? {
        ...commonResult,
        upsertedId: replaceRawId(resp.status?.upsertedId),
        upsertedCount: 1,
      }
      : commonResult;
  }

  /**
   * Replaces a single document in the collection.
   *
   * If `upsert` is set to true, it will insert the replacement regardless of if no match is found.
   *
   * See {@link ReplaceOneOptions} for complete information about the options available for this operation.
   *
   * @example
   * ```typescript
   * await collection.insertOne({
   *   _id: '1',
   *   name: 'John Doe',
   *   $vector: [.12, .52, .32],
   * });
   *
   * // Replace by ID
   * await collection.replaceOne({ _id: '1' }, { name: 'Jane Doe' });
   *
   * // Replace by name
   * await collection.replaceOne({
   *   name: 'John Doe',
   * }, {
   *   name: 'Jane Doe',
   * });
   *
   * // Replace by vector
   * await collection.replaceOne({}, {
   *   name: 'Jane Doe'
   * }, {
   *   vector: [.09, .58, .22],
   * });
   *
   * // Upsert if no match
   * await collection.replaceOne({
   *   name: 'Lynyrd Skynyrd',
   * }, {
   *   name: 'Lenerd Skinerd',
   * }, {
   *   upsert: true,
   * });
   * ```
   *
   * @param filter - A filter to select the document to replace.
   * @param replacement - The replacement document, which contains no `_id` field.
   * @param options - The options for this operation.
   *
   * @return The result of the operation.
   *
   * @see StrictFilter
   */
  async replaceOne(filter: Filter<Schema>, replacement: NoId<Schema>, options?: ReplaceOneOptions<Schema>): Promise<ReplaceOneResult> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: FindOneAndReplaceCommand = {
      findOneAndReplace: {
        filter,
        replacement,
        options: {
          returnDocument: 'before',
          upsert: options?.upsert,
        },
        projection: { _id: 0 },
      },
    };

    if (options?.sort) {
      command.findOneAndReplace.sort = options.sort;
    }

    const resp = await this._httpClient.executeCommand(command, options, findOneAndReplaceOptionsKeys);

    const commonResult = {
      modifiedCount: resp.status?.modifiedCount,
      matchedCount: resp.status?.matchedCount,
    } as const;

    return (resp.status?.upsertedId)
      ? {
        ...commonResult,
        upsertedId: replaceRawId(resp.status?.upsertedId),
        upsertedCount: 1,
      }
      : commonResult;
  }

  /**
   * Atomically deletes a single document from the collection.
   *
   * You can specify a `sort` option to determine which document to delete if multiple documents match the filter.
   *
   * See {@link DeleteOneOptions} for complete information about the options available for this operation.
   *
   * @example
   * ```typescript
   * // Delete by _id
   * await collection.insertOne({ _id: '1', name: 'John Doe' });
   * await collection.deleteOne({ _id: '1' });
   *
   * // Delete by name
   * await collection.insertOne({ name: 'Jane Doe', age: 25 });
   * await collection.insertOne({ name: 'Jane Doe', age: 33 });
   * await collection.deleteOne({ name: 'Jane Doe' }, { sort: { age: -1 } });
   *
   * // Delete by vector
   * await collection.insertOne({ name: 'Jane Doe', $vector: [.12, .52, .32] });
   * await collection.deleteOne({}, { vector: [.09, .58, .42] });
   * ```
   *
   * @param filter - A filter to select the document to delete.
   * @param options - The options for this operation.
   *
   * @return The result of the operation.
   *
   * @see StrictFilter
   */
  async deleteOne(filter: Filter<Schema> = {}, options?: DeleteOneOptions<Schema>): Promise<DeleteOneResult> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: DeleteOneCommand = {
      deleteOne: { filter },
    };

    if (options?.sort) {
      command.deleteOne.sort = options.sort;
    }

    const deleteOneResp = await this._httpClient.executeCommand(command, options);

    return {
      deletedCount: deleteOneResp.status?.deletedCount,
    };
  }

  /**
   * Deletes many documents from the collection.
   *
   * **NB. This function paginates the deletion of documents in chunks to avoid running into insertion limits. This
   * means multiple requests may be made to the server, and the operation may not be atomic.**
   *
   * If an empty filter is passed, an error will be thrown, asking you to use {@link deleteAll} instead for your safety.
   *
   * @example
   * ```typescript
   * await collection.insertMany([
   *   { _id: '1', name: 'John Doe' },
   *   { name: 'John Doe' },
   * ]);
   *
   * await collection.deleteMany({ name: 'John Doe' });
   * ```
   *
   * @remarks
   * This operation is not atomic. Depending on the amount of matching documents, it can keep running (in a blocking
   * way) for a macroscopic amount of time. In that case, new documents that are inserted from another concurrent process/
   * application at the same time may be deleted during the execution of this method call. In other words, it cannot
   * easily be predicted whether a given newly-inserted document will be picked up by the deleteMany command or not.
   *
   * @param filter - A filter to select the documents to delete.
   *
   * @return The aggregated result of the operation.
   *
   * @throws Error - If an empty filter is passed.
   *
   * @see StrictFilter
   */
  async deleteMany(filter: Filter<Schema> = {}): Promise<DeleteManyResult> {
    if (Object.keys(filter).length === 0) {
      throw new Error('Can\'t pass an empty filter to deleteMany, use deleteAll instead if you really want to delete everything');
    }

    const command: DeleteManyCommand = {
      deleteMany: { filter },
    };

    let resp;
    let numDeleted = 0;

    try {
      while (!resp || resp.status?.moreData) {
        resp = await this._httpClient.executeCommand(command);
        numDeleted += resp.status?.deletedCount ?? 0;
      }
    } catch (e) {
      if (!(e instanceof DataAPIResponseError)) {
        throw e;
      }
      const desc = e.detailedErrorDescriptors[0];
      throw mkRespErrorFromResponse(DeleteManyError, command, desc.rawResponse, { deletedCount: numDeleted + (desc.rawResponse?.status?.deletedCount ?? 0) })
    }

    return {
      deletedCount: numDeleted,
    };
  }

  /**
   * Deletes all documents from the collection.
   *
   * Unlike {@link deleteMany}, this method is atomic and will delete all documents in the collection in one go,
   * without making multiple network requests to the server.
   *
   * @remarks Use with caution. Wear a helmet. Don't say I didn't warn you.
   */
  async deleteAll(): Promise<void> {
    const command: DeleteManyCommand = {
      deleteMany: { filter: {} },
    };

    await this._httpClient.executeCommand(command);
  }

  /**
   * Find documents on the collection, optionally matching the provided filter.
   *
   * Also accepts `sort`, `limit`, `skip`, `includeSimilarity`, and `projection` options.
   *
   * The method returns a {@link FindCursor} that can then be iterated over.
   *
   * **NB. If a *non-vector-sort* `sort` option is provided, the iteration of all documents may not be atomic—it will
   * iterate over cursors in an approximate way, exhibiting occasional skipped or duplicate documents, with real-time
   * collection mutations being displayed**
   *
   * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
   * @param options - The options for this operation.
   *
   * @return FindCursor
   */
  find<GetSim extends boolean = false>(filter: Filter<Schema>, options?: FindOptions<Schema, GetSim>): FindCursor<FoundDoc<Schema, GetSim>, FoundDoc<Schema, GetSim>> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    return new FindCursor(this.namespace, this._httpClient, filter, options) as any;
  }

  async distinct<Key extends string, GetSim extends boolean = false>(key: Key, filter: Filter<Schema> = {}, _?: FindOptions<Schema, GetSim>): Promise<Flatten<(SomeDoc & ToDotNotation<FoundDoc<Schema, GetSim>>)[Key]>[]> {
    assertPathSafe4Distinct(key);

    const projection = pullSafeProjection4Distinct(key);
    const cursor = this.find<GetSim>(filter, { projection: { _id: 0, [projection]: 1 } });

    const seen = new Set<unknown>();
    const ret = [];

    const extract = mkDistinctPathExtractor(key);

    for await (const doc of cursor) {
      const values = extract(doc);

      for (let i = 0, n = values.length; i < n; i++) {
        if (typeof values[i] === 'object') {
          const hash = objectHash(values[i]);

          if (!seen.has(hash)) {
            seen.add(hash);
            ret.push(values[i]);
          }
        } else {
          if (!seen.has(values[i])) {
            seen.add(values[i]);
            ret.push(values[i]);
          }
        }
      }
    }

    return ret;
  }

  /**
   * Finds a single document in the collection.
   *
   * You can specify a `sort` option to determine which document to find if multiple documents match the filter.
   *
   * You can also specify a `projection` option to determine which fields to include in the returned document.
   *
   * If sorting by `$vector`, you can set the `includeSimilarity` option to `true` to include the similarity score in the
   * returned document as `$similarity: number`.
   *
   * @example
   * ```typescript
   * const doc = await collection.findOne({}, {
   *   sort: {
   *     $vector: [.12, .52, .32],
   *   },
   *   includeSimilarity: true,
   * });
   *
   * console.log(doc?.$similarity);
   * ```
   *
   * @remarks
   * If you really need `limit` or `skip`, prefer using the {@link find} method instead.
   *
   * @param filter - A filter to select the document to find.
   * @param options - The options for this operation.
   *
   * @return The found document, or `null` if no document was found.
   */
  async findOne<GetSim extends boolean = false>(filter: Filter<Schema>, options?: FindOneOptions<Schema, GetSim>): Promise<FoundDoc<Schema, GetSim> | null> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: FindOneCommand = {
      findOne: {
        filter,
        options: {
          includeSimilarity: options?.includeSimilarity,
        }
      },
    };

    if (options?.sort) {
      command.findOne.sort = options.sort;
    }

    if (options?.projection && Object.keys(options.projection).length > 0) {
      command.findOne.projection = options.projection;
    }

    const resp = await this._httpClient.executeCommand(command, options, findOneOptionsKeys);
    return replaceRawId(resp.data?.document);
  }

  /**
   * Atomically finds a single document in the collection and replaces it.
   *
   * Set `returnDocument` to `'after'` to return the document as it is after the replacement, or `'before'` to return the
   * document as it was before the replacement.
   *
   * You can specify a `sort` option to determine which document to find if multiple documents match the filter.
   *
   * You can also set `projection` to determine which fields to include in the returned document.
   *
   * You can also set `upsert` to `true` to insert a new document if no document matches the filter.
   *
   * @example
   * ```typescript
   * const doc = await collection.findOneAndReplace(
   *   { _id: '1' },
   *   { _id: '1', name: 'John Doe' },
   *   { returnDocument: 'after' }
   * );
   *
   * // Prints { _id: '1', name: 'John Doe' }
   * console.log(doc);
   * ```
   *
   * @param filter - A filter to select the document to find.
   * @param replacement - The replacement document, which contains no `_id` field.
   * @param options - The options for this operation.
   *
   * @return ModifyResult
   */
  async findOneAndReplace(
    filter: Filter<Schema>,
    replacement: NoId<Schema>,
    options: FindOneAndReplaceOptions<Schema> & { includeResultMetadata: true },
  ): Promise<ModifyResult<Schema>>

  async findOneAndReplace(
    filter: Filter<Schema>,
    replacement: NoId<Schema>,
    options: FindOneAndReplaceOptions<Schema> & { includeResultMetadata?: false },
  ): Promise<WithId<Schema> | null>

  async findOneAndReplace(filter: Filter<Schema>, replacement: NoId<Schema>, options: FindOneAndReplaceOptions<Schema>): Promise<ModifyResult<Schema> | WithId<Schema> | null> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: FindOneAndReplaceCommand = {
      findOneAndReplace: {
        filter,
        replacement,
        options: {
          returnDocument: options.returnDocument,
          upsert: options.upsert,
        },
      },
    };

    if (options?.sort) {
      command.findOneAndReplace.sort = options.sort;
    }

    if (options?.projection && Object.keys(options.projection).length > 0) {
      command.findOneAndReplace.projection = options.projection;
    }

    const resp = await this._httpClient.executeCommand(command, options, findOneAndReplaceOptionsKeys);
    const document = replaceRawId(resp.data?.document);

    return (options.includeResultMetadata)
      ? {
        value: document,
        ok: 1,
      }
      : document;
  }

  /**
   * Counts the number of documents in the collection, optionally with a filter.
   *
   * Takes in a `limit` option which dictates the maximum number of documents that may be present before a
   * {@link TooManyDocsToCountError} is thrown. If the limit is higher than the highest limit accepted by the
   * Data API, a {@link TooManyDocsToCountError} will be thrown anyway (i.e. `1000`).
   *
   * @example
   * ```typescript
   * await collection.insertMany([
   *   { _id: '1', name: 'John Doe' },
   *   { name: 'Jane Doe' },
   * ]);
   *
   * const count = await collection.countDocuments({ name: 'John Doe' }, 1000);
   * console.log(count); // 1
   *
   * // Will throw a TooManyDocsToCountError as it counts 1, but the limit is 0
   * const count = await collection.countDocuments({ name: 'John Doe' }, 0);
   * ```
   *
   * @remarks
   * Count operations are expensive: for this reason, the best practice is to provide a reasonable `upperBound`
   * according to the caller expectations. Moreover, indiscriminate usage of count operations for sizeable amounts
   * of documents (i.e. in the thousands and more) is discouraged in favor of alternative application-specific
   * solutions. Keep in mind that the Data API has a hard upper limit on the amount of documents it will count,
   * and that an exception will be thrown by this method if this limit is encountered.
   *
   * @param filter - A filter to select the documents to count. If not provided, all documents will be counted.
   * @param upperBound - The maximum number of documents to count.
   * @param options - The options for this operation.
   *
   * @throws TooManyDocsToCountError - If the number of documents counted exceeds the provided limit.
   */
  async countDocuments(filter: Filter<Schema>, upperBound: number, options?: BaseOptions): Promise<number> {
    const command = {
      countDocuments: { filter },
    };

    if (!upperBound) {
      throw new Error('options.limit is required');
    }

    const resp = await this._httpClient.executeCommand(command, options);

    if (resp.status?.count > upperBound) {
      throw new TooManyDocsToCountError(upperBound, false);
    }

    if (resp.status?.moreData) {
      throw new TooManyDocsToCountError(resp.status.count, true);
    }

    return resp.status?.count;
  }

  /**
   * Atomically finds a single document in the collection and deletes it.
   *
   * You can specify a `sort` option to determine which document to find if multiple documents match the filter.
   *
   * You can also set `projection` to determine which fields to include in the returned document.
   *
   * @example
   * ```typescript
   * await collection.insertOne({ _id: '1', name: 'John Doe' });
   * const doc = await collection.findOneAndDelete({ _id: '1' });
   * console.log(doc); // The deleted document
   * ```
   *
   * @param filter - A filter to select the document to find.
   * @param options - The options for this operation.
   *
   * @return
   *  if `includeResultMetadata` is `true`, a `ModifyResult` object with the deleted document and the `ok` status.
   *  Otherwise, the deleted document, or `null` if no document was found.
   */
  async findOneAndDelete(
    filter: Filter<Schema>,
    options?: FindOneAndDeleteOptions<Schema> & { includeResultMetadata: true },
  ): Promise<ModifyResult<Schema>>

  async findOneAndDelete(
    filter: Filter<Schema>,
    options?: FindOneAndDeleteOptions<Schema> & { includeResultMetadata?: false },
  ): Promise<WithId<Schema> | null>

  async findOneAndDelete(filter: Filter<Schema>, options?: FindOneAndDeleteOptions<Schema>): Promise<ModifyResult<Schema> | WithId<Schema> | null> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: FindOneAndDeleteCommand = {
      findOneAndDelete: { filter },
    };

    if (options?.sort) {
      command.findOneAndDelete.sort = options.sort;
    }

    if (options?.projection && Object.keys(options.projection).length > 0) {
      command.findOneAndDelete.projection = options.projection;
    }

    const resp = await this._httpClient.executeCommand(command, options);
    const document = replaceRawId(resp.data?.document);

    return (options?.includeResultMetadata)
      ? {
        value: document,
        ok: 1,
      }
      : document;
  }

  /**
   * Finds a single document in the collection and updates it.
   *
   * Set `returnDocument` to `'after'` to return the document as it is after the update, or `'before'` to return the
   * document as it was before the update.
   *
   * You can specify a `sort` option to determine which document to find if multiple documents match the filter.
   *
   * You can also set `upsert` to `true` to insert a new document if no document matches the filter.
   *
   * @example
   * ```typescript
   * const doc = await collection.findOneAndUpdate(
   *   { _id: '1' },
   *   { $set: { name: 'Jane Doe' } },
   *   { returnDocument: 'after' }
   * );
   *
   * // Prints { _id: '1', name: 'Jane Doe' }
   * console.log(doc);
   * ```
   *
   * @param filter - A filter to select the document to find.
   * @param update - The update to apply to the selected document.
   * @param options - The options for this operation.
   */
  async findOneAndUpdate(
    filter: Filter<Schema>,
    update: UpdateFilter<Schema>,
    options: FindOneAndUpdateOptions<Schema> & { includeResultMetadata: true },
  ): Promise<ModifyResult<Schema>>

  async findOneAndUpdate(
    filter: Filter<Schema>,
    update: UpdateFilter<Schema>,
    options: FindOneAndUpdateOptions<Schema> & { includeResultMetadata?: false },
  ): Promise<WithId<Schema> | null>

  async findOneAndUpdate(filter: Filter<Schema>, update: UpdateFilter<Schema>, options: FindOneAndUpdateOptions<Schema>): Promise<ModifyResult<Schema> | WithId<Schema> | null> {
    if (options?.vector) {
      if (options.sort) {
        throw new Error('Can\'t use both `sort` and `vector` options at once; if you need both, include a $vector key in the sort object')
      }
      options = { ...options, sort: { $vector: options.vector } };
    }

    const command: FindOneAndUpdateCommand = {
      findOneAndUpdate: {
        filter,
        update,
        options: {
          returnDocument: options.returnDocument,
          upsert: options.upsert,
        },
      },
    };

    if (options?.sort) {
      command.findOneAndUpdate.sort = options.sort;
    }

    if (options?.projection && Object.keys(options.projection).length > 0) {
      command.findOneAndUpdate.projection = options.projection;
    }

    const resp = await this._httpClient.executeCommand(command, options, findOneAndUpdateOptionsKeys);
    const document = replaceRawId(resp.data?.document);

    return (options.includeResultMetadata)
      ? {
        value: document,
        ok: 1,
      }
      : document;
  }

  /**
   * Execute arbitrary operations sequentially/concurrently on the collection, such as insertions, updates, replaces,
   * & deletions, **non-atomically**
   *
   * Each operation is treated as a separate, unrelated request to the server; it is not performed in a transaction.
   *
   * You can set the `ordered` option to `true` to stop the operations after the first error, otherwise all operations
   * may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
   *
   * *Note that the bulkWrite being ordered has nothing to do with if the operations themselves are ordered or not.*
   *
   * If an operational error occurs, the operation will throw a {@link BulkWriteError} containing the partial result.
   *
   * *If the exception is not due to a soft `2XX` error, e.g. a `5xx` error or network error, the operation will throw
   * the underlying error.*
   *
   * *In case of an unordered request, if the error was a simple operational error, a `BulkWriteError` will be thrown
   * after every operation has been attempted. If it was a `5xx` or similar, the error will be thrown immediately.*
   *
   * You can set the `parallel` option to control how many network requests are made in parallel on unordered
   * insertions. Defaults to `8`.
   *
   * @example
   * ```typescript
   * try {
   *   // Insert a document, then delete it
   *   await collection.bulkWrite([
   *     { insertOne: { document: { _id: '1', name: 'John Doe' } } },
   *     { deleteOne: { filter: { name: 'John Doe' } } },
   *   ]);
   *
   *   // Insert and delete operations, will cause a data race
   *   await collection.bulkWrite([
   *     { insertOne: { document: { _id: '1', name: 'John Doe' } } },
   *     { deleteOne: { filter: { name: 'John Doe' } } },
   *   ]);
   * } catch (e) {
   *   if (e instanceof BulkWriteError) {
   *     console.log(e.insertedCount);
   *     console.log(e.deletedCount);
   *   }
   * }
   * ```
   *
   * @param operations
   * @param options
   *
   * @return BulkWriteResult
   *
   * @throws BulkWriteError - If the operation fails
   */
  async bulkWrite(operations: AnyBulkWriteOperation<Schema>[], options?: BulkWriteOptions): Promise<BulkWriteResult> {
    const commands = operations.map(buildBulkWriteCommands);

    return (options?.ordered)
      ? await bulkWriteOrdered(this._httpClient, commands)
      : await bulkWriteUnordered(this._httpClient, commands, options?.parallel ?? 8);
  }

  /**
   * Get the collection options, i.e. its configuration as read from the database.
   *
   *  The method issues a request to the Data API each time is invoked,
   *         without caching mechanisms: this ensures up-to-date information
   *         for usages such as real-time collection validation by the application.
   *
   * @return The options that the collection was created with (i.e. the `vector` and `indexing` operations).
   */
  async options(): Promise<CollectionOptions<SomeDoc>> {
    const results = await this._db.listCollections({ nameOnly: false });

    const collection = results.find((c) => c.name === this.collectionName);

    if (!collection) {
      throw new Error(`Collection ${this.collectionName} not found`);
    }

    return collection.options ?? {};
  }

  /**
   * Drops the collection from the database, including all the documents it contains.
   *
   * @example
   * ```typescript
   * const collection = await db.createCollection('my_collection');
   * await collection.drop();
   * ```
   *
   * @param options - The options for this operation.
   *
   * @return `true` if the collection was dropped okay.
   */
  async drop(options?: BaseOptions): Promise<boolean> {
    return await this._db.dropCollection(this.collectionName, options);
  }
}

// -- Insert Many ------------------------------------------------------------------------------------------

const insertManyOrdered = async <Schema>(httpClient: DataApiHttpClient, documents: unknown[], chunkSize: number): Promise<IdOf<Schema>[]> => {
  const insertedIds: IdOf<Schema>[] = [];

  for (let i = 0, n = documents.length; i < n; i += chunkSize) {
    const slice = documents.slice(i, i + chunkSize);

    try {
      const inserted = await insertMany<Schema>(httpClient, slice, true);
      insertedIds.push(...inserted);
    } catch (e) {
      if (!(e instanceof DataAPIResponseError)) {
        throw e;
      }
      const desc = e.detailedErrorDescriptors[0];

      insertedIds.push(...desc.rawResponse.status?.insertedIds ?? []);
      throw mkRespErrorFromResponse(InsertManyError, desc.command, desc.rawResponse, { insertedIds: insertedIds, insertedCount: insertedIds.length })
    }
  }

  return insertedIds;
}

const insertManyUnordered = async <Schema>(httpClient: DataApiHttpClient, documents: unknown[], concurrency: number, chunkSize: number): Promise<IdOf<Schema>[]> => {
  const insertedIds: IdOf<Schema>[] = [];
  let masterIndex = 0;

  const failCommands = [] as Record<string, any>[];
  const failRaw = [] as Record<string, any>[];

  const workers = Array.from({ length: concurrency }, async () => {
    while (masterIndex < documents.length) {
      const localI = masterIndex;
      const endIdx = Math.min(localI + chunkSize, documents.length);
      masterIndex += chunkSize;

      if (localI >= endIdx) {
        break;
      }

      const slice = documents.slice(localI, endIdx);

      try {
        const inserted = await insertMany<Schema>(httpClient, slice, false);
        insertedIds.push(...inserted);
      } catch (e) {
        if (!(e instanceof DataAPIResponseError)) {
          throw e;
        }
        const desc = e.detailedErrorDescriptors[0];

        const justInserted = desc.rawResponse.status?.insertedIds ?? [];
        insertedIds.push(...justInserted);

        failCommands.push(desc.command);
        failRaw.push(desc.rawResponse);
      }
    }
  });
  await Promise.all(workers);

  if (failCommands.length > 0) {
    throw mkRespErrorFromResponses(InsertManyError, failCommands, failRaw, { insertedIds: insertedIds, insertedCount: insertedIds.length });
  }

  return insertedIds;
}

const insertMany = async <Schema>(httpClient: DataApiHttpClient, documents: unknown[], ordered: boolean): Promise<IdOf<Schema>[]> => {
  const command: InsertManyCommand = {
    insertMany: {
      documents,
      options: { ordered },
    }
  }

  const resp = await httpClient.executeCommand(command, {}, insertManyOptionKeys);
  return resp.status?.insertedIds ?? [];
}

// -- Bulk Write ------------------------------------------------------------------------------------------

const bulkWriteOrdered = async (httpClient: DataApiHttpClient, operations: Record<string, any>[]): Promise<BulkWriteResult> => {
  const results = new BulkWriteResult();
  let i = 0;

  try {
    for (let n = operations.length; i < n; i++) {
      const resp = await httpClient.executeCommand(operations[i], {});
      addToBulkWriteResult(results, resp.status!, i);
    }
  } catch (e) {
    if (!(e instanceof DataAPIResponseError)) {
      throw e;
    }
    const desc = e.detailedErrorDescriptors[0];

    if (desc.rawResponse.status) {
      addToBulkWriteResult(results, desc.rawResponse.status, i)
    }

    throw mkRespErrorFromResponse(BulkWriteError, desc.command, desc.rawResponse, results);
  }

  return results;
}

const bulkWriteUnordered = async (httpClient: DataApiHttpClient, operations: Record<string, any>[], parallel: number): Promise<BulkWriteResult> => {
  const results = new BulkWriteResult();
  let masterIndex = 0;

  const failCommands = [] as Record<string, any>[];
  const failRaw = [] as Record<string, any>[];

  const workers = Array.from({ length: parallel }, async () => {
    while (masterIndex < operations.length) {
      const localI = masterIndex;
      masterIndex++;

      if (localI >= operations.length) {
        break;
      }

      const command = operations[localI];

      try {
        const resp = await httpClient.executeCommand(command, {});
        addToBulkWriteResult(results, resp.status!, localI);
      } catch (e) {
        if (!(e instanceof DataAPIResponseError)) {
          throw e;
        }
        const desc = e.detailedErrorDescriptors[0];

        if (desc.rawResponse.status) {
          addToBulkWriteResult(results, desc.rawResponse.status, localI);
        }

        failCommands.push(desc.command);
        failRaw.push(desc.rawResponse);
      }
    }
  });
  await Promise.all(workers);

  if (failCommands.length > 0) {
    throw mkRespErrorFromResponses(BulkWriteError, failCommands, failRaw, results);
  }

  return results;
}

const buildBulkWriteCommands = (operations: Record<string, any>): Record<string, any> => {
  const commandName = Object.keys(operations)[0];
  switch (commandName) {
    case 'insertOne': return { insertOne: { document: operations.insertOne.document } };
    case 'updateOne': return { updateOne: { filter: operations.updateOne.filter, update: operations.updateOne.update, options: { upsert: operations.updateOne.upsert ?? false } } };
    case 'updateMany': return { updateMany: { filter: operations.updateMany.filter, update: operations.updateMany.update, options: { upsert: operations.updateMany.upsert ?? false } } };
    case 'replaceOne': return { findOneAndReplace: { filter: operations.replaceOne.filter, replacement: operations.replaceOne.replacement, options: { upsert: operations.replaceOne.upsert ?? false } } };
    case 'deleteOne': return { deleteOne: { filter: operations.deleteOne.filter } };
    case 'deleteMany': return { deleteMany: { filter: operations.deleteMany.filter } };
    default: throw new Error(`Unknown bulk write operation: ${commandName}`);
  }
}

const addToBulkWriteResult = (result: BulkWriteResult, resp: Record<string, any>, i: number) => {
  const asMutable = result as Mutable<BulkWriteResult>;

  asMutable.insertedCount += resp.insertedIds?.length ?? 0;
  asMutable.modifiedCount += resp.modifiedCount ?? 0;
  asMutable.matchedCount += resp.matchedCount ?? 0;
  asMutable.deletedCount += resp.deletedCount ?? 0;

  if (resp.upsertedId) {
    asMutable.upsertedCount++;
    asMutable.upsertedIds[i] = replaceRawId(resp.upsertedId);
  }

  asMutable.getRawResponse().push(resp);
}

// -- Distinct --------------------------------------------------------------------------------------------

const assertPathSafe4Distinct = (path: string): void => {
  const split = path.split('.');

  if (split.length === 0) {
    throw new Error('Path cannot be empty');
  }

  if (split.some(p => !p)) {
    throw new Error('Path cannot contain empty segments');
  }
}

const pullSafeProjection4Distinct = (path: string): string => {
  return takeWhile(path.split('.'), p => isNaN(p as any)).join('.');
}

const mkDistinctPathExtractor = (path: string): (doc: SomeDoc) => any[] => {
  const values = [] as any[];

  const extract = (path: string[], index: number, value: any) => {
    if (!value) {
      return;
    }

    if (index === path.length) {
      if (Array.isArray(value)) {
        values.push(...value);
      } else {
        values.push(value);
      }
      return;
    }

    const prop = path[index];

    if (Array.isArray(value)) {
      const asInt = parseInt(prop, 10);

      if (isNaN(asInt)) {
        for (let i = 0, n = value.length; i < n; i++) {
          extract(path, index, value[i]);
        }
      } else if (asInt < value.length) {
        extract(path, index + 1, value[asInt]);
      }
    } else if (value && typeof value === 'object') {
      extract(path, index + 1, value[prop]);
    }
  }

  return (doc: SomeDoc) => {
    extract(path.split('.'), 0, doc);
    return values;
  };
}
